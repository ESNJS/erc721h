/// @title ERC721A
/// @author Philogy
/// @author bmwoolf
/// @notice A reusable base implementation of the ERC721A token contract written in Huff

/* Imports */
#include "./utils/HashMap.huff"
#include "./utils/Misc.huff"

/* ERC721 Interface */

/* ERC721 Interface -- Events */
#define event Transfer(address, address, uint256)
#define event Approval(address, address, uint256)
#define event ApprovalForAll(address, address, bool)

/* ERC721 Interface -- Metadata */
#define function name() nonpayable returns (string)
#define function symbol() nonpayable returns (string)
#define function tokenURI(uint256) nonpayable returns (string)

/* ERC721 Interface -- Transfer */
#define function transferFrom(address, address, uint256) nonpayable returns ()
#define function safeTransferFrom(address, address, uint256) nonpayable returns ()
#define function safeTransferFrom(address, address, uint256, bytes) nonpayable returns ()
// added sigs as constants to avoid having to use __FUNC_SIG("...")
#define constant SIG_NO_DATA_SAFE_TRANSFER_FROM = 0x42842e0e
#define constant SIG_DATA_SAFE_TRANSFER_FROM = 0xb88d4fde

/* ERC721 Interface -- Allowance */
#define function getApproved(uint256) view returns (address)
#define function isApprovedForAll(address, address) view returns (uint256)
#define function approve(address, uint256) nonpayable returns ()
#define function setApprovalForAll(address, bool) nonpayable returns ()

/* ERC721 Interface -- Ownership */
#define function ownerOf(uint256) view returns (address)
#define function balanceOf(address) view returns (uint256)

/* ERC721 Interface -- Receiver */
#define function onERC721Received(address, address, uint256, bytes) nonpayable returns (bytes4)

/* ERC165 */
#define function supportsInterface(bytes4) view returns (bool)

/* ERC721H */
#define constant ERC721H__START_TOKEN_ID = 0x0


/* Storage Layout */
// _currentIndex (size: 128, offset: 0) - The next token ID to be minted
// _burnCounter (size: 128, offset: 128) - Global amount of tokens burnt
#define constant ERC721H_SLOT__GLOBAL_INDICES = FREE_STORAGE_POINTER()

#define macro ERC721H_CONSTRUCTOR() = takes(0) returns(0) {
  [START_TOKEN_ID] [SLOT_GLOBAL_INDICES] sstore // _currentIndex = START_TOKEN_ID
}

// only 13 methods but 16 possible bit sequences, gaps filled with continue label
#define jumptable __ERC721H__SELECTOR_TABLE {
  __ERC721H__balanceOf
  __ERC721H__selectorSwitchEnd // gap
  __ERC721H__supportsInterface
  __ERC721H__dataSafeTransferFrom
  __ERC721H__getApproved
  __ERC721H__tokenURI
  __ERC721H__symbol
  __ERC721H__name
  __ERC721H__ownerOf
  __ERC721H__approve
  __ERC721H__isApprovedForAll
  __ERC721H__noDataSafeTransferFrom
  __ERC721H__transferFrom
  __ERC721H__setApprovalForAll
  __ERC721H__selectorSwitchEnd // gap
  __ERC721H__selectorSwitchEnd // gap
}

/**
 * TODO: Future macro args name, symbol, tokenURI, supportsInterface
 * @dev the 13 ERC721 methods each have a unique 4-bit sequence 10 bits in
 * which is used for the constant lookup in the jump table
 */
#define macro ERC721H_SELECTOR_SWITCH(name, symbol, tokenURI) = takes(1) returns(1) {
  // takes:         [selector]
  0x20           // [0x20, selector]
  // needs to be multiplied by 32 (<< 5) for table offset
  // >> 10; << 5; simplifies to >> 5
  dup2 0x5 shr   // [selector >> 5, 0x20 selector]
  // 4-bit mask shift left 5 to meet selector
  0x1e0 and      // [table_offset, 0x20, selector]
  __tablestart(__ERC721H__SELECTOR_TABLE) add
  //                [code_offset, 0x20, selector]
  returndatasize // [0x0, code_offset, 0x20, selector]
  codecopy       // [selector]
  returndatasize // [0x0, selector]
  mload jump     // [selector]

  // direct signature comparison to check for collisions, necessary for this
  // switch to be used with more methods
  __ERC721H__balanceOf:
    dup1 __FUNC_SIG(balanceOf) eq iszero __ERC721H__selectorSwitchEnd jumpi
  __ERC721H__supportsInterface:
    dup1 __FUNC_SIG(supportsInterface) eq iszero __ERC721H__selectorSwitchEnd jumpi
  __ERC721H__dataSafeTransferFrom:
    dup1 [SIG_DATA_SAFE_TRANSFER_FROM] eq iszero __ERC721H__selectorSwitchEnd jumpi
  __ERC721H__getApproved:
    dup1 __FUNC_SIG(getApproved) eq iszero __ERC721H__selectorSwitchEnd jumpi
  __ERC721H__tokenURI:
    dup1 __FUNC_SIG(tokenURI) eq iszero __ERC721H__selectorSwitchEnd jumpi
    <tokenURI> jump
  __ERC721H__symbol:
    dup1 __FUNC_SIG(symbol) eq iszero __ERC721H__selectorSwitchEnd jumpi
    <symbol> jump
  __ERC721H__name:
    dup1 __FUNC_SIG(name) eq iszero __ERC721H__selectorSwitchEnd jumpi
    <name> jump
  __ERC721H__ownerOf:
    dup1 __FUNC_SIG(ownerOf) eq iszero __ERC721H__selectorSwitchEnd jumpi
  __ERC721H__approve:
    dup1 __FUNC_SIG(approve) eq iszero __ERC721H__selectorSwitchEnd jumpi
  __ERC721H__isApprovedForAll:
    dup1 __FUNC_SIG(isApprovedForAll) eq iszero __ERC721H__selectorSwitchEnd jumpi
  __ERC721H__noDataSafeTransferFrom:
    dup1 [SIG_NO_DATA_SAFE_TRANSFER_FROM] eq iszero __ERC721H__selectorSwitchEnd jumpi
  __ERC721H__transferFrom:
    dup1 __FUNC_SIG(transferFrom) eq iszero __ERC721H__selectorSwitchEnd jumpi
  __ERC721H__setApprovalForAll:
    dup1 __FUNC_SIG(setApprovalForAll) eq iszero __ERC721H__selectorSwitchEnd jumpi

  __ERC721H__selectorSwitchEnd:
}

// TODO: Remove, only to appease compiler
#define macro MAIN() = takes(0) returns(0) {
  GET_SELECTOR()
  ERC721H_SELECTOR_SWITCH()
}
